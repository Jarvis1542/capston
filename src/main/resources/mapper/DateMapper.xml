<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.fivekm_home.charge.mapper.DataIntfMapper">

    <!-- 월의 1~31일자 조회 -->
    <select id="DateMonthXML" resultType="com.fivekm_home.charge.domain.DATE.DateMonthDAO">
        SELECT
            MONTHS + LEVEL -1 "DAYS"
        FROM (
            SELECT TO_DATE(#{DATE_SEND}, 'yyyymmdd') "MONTHS"
            FROM DUAL
        )
        CONNECT BY MONTHS + LEVEL -1 <![CDATA[<=]]> LAST_DAY(MONTHS)
    </select>

    <select id="DateWeekXML" resultType="com.fivekm_home.charge.domain.DATE.DateWeekDAO">
        -- set_mon 은 dt의 최소값을 가져오고 월만 구한다.
        SELECT TO_CHAR(MIN(dt), 'mm') set_mon
            -- 한 주의 기준에서 예를 들어 7월 27일에서 8월 2일이라하면 MAX 최대 값은
            -- 8월 2일이다 거기서 마이너스 MIN 최소 값은  7월 27일인데 거기서 mm
            -- 월의 첫번째 일 7월 1일을 가져오고 2 월요일을 찾아서 7월 6일이 된다
            -- 8월 2일과 7월 6일을 빼면 27일이 되고 + 1을 하면 28이 되고 / 7을하면 4가되어
            -- 4주차가 되는 것이다.
            , (MAX(dt) - NEXT_DAY(TRUNC(MIN(dt), 'mm')-1, 2) + 1) / 7 set_week
            , TO_DATE(TO_CHAR(MIN(dt), 'yyyy/mm/dd'), 'YYYY/MM/DD') set_weekstart
            , TO_DATE(TO_CHAR(MAX(dt), 'yyyy/mm/dd'), 'YYYY/MM/DD') set_weekend
            FROM (
                -- dt에서 mm month의 월의 1일 값을 구하고 주초의 월요일을 구한다 iw
                -- + LEVEL - 1 을 하여 0부터 42까지 반복 dt로 다시 선언
                -- 만약 2020년 8월달을 기준으로 1일을 찾고
                -- iw로 월요일을 찾을 때 이전달 7월의 마지막주의 월요일이 7월 27일이라 하면
                -- 27일부터 9월 6일까지 42일 반복 시키겠다는 의미
                -- 여기서 한가지 또 중요한 것 group by 때문에 주간이 기준이 되기 때문에
                -- 7월 27일에서 8월 2일이 한 주가 되어 기준이 된다 한주씩 반복 되어 찾아준다.
                SELECT TRUNC(TRUNC(dt, 'mm'), 'iw') + LEVEL - 1 dt
                FROM (
                    -- 20131008이 없으면 현재 시각으로 as dt로 선언
                    SELECT NVL(TO_DATE(#{DATE_SEND}, 'yyyymmdd'), sysdate) dt
                    FROM dual
                )
                -- TRUNC(LAST_DAY(sysdate), 'iw') + 6 - TRUNC(TRUNC(sysdate, 'mm'), 'iw') + 1
                -- 를 돌려보면 42가 나온다 42를 돌리는 이유는 달력에서 이전달 다음달 주차까지 합치면
                -- 42일이 나온다 6주차라는 말. 7 * 6 = 42
                -- LAST_DAY(dt) 는 2020년 8월기준으로는 31일이 마지막이고 iw 를 하면 주초의 월요일을 찾는데
                -- 31일이 월요일이기 때문에 + 6을 하면 9월달의 다음주가 찾아진다.
                -- TRUNC(dt, 'mm') 은 8월의 1일을 찾고 iw 월요일을 찾으면 7월의 월요일 7월 27일을 찾고
                -- + 1을 하면 화요일 7월 28일을 찾게 된다.
                -- 7월 28일과 9월 6일을 빼면 42일이다
                CONNECT BY LEVEL <![CDATA[<=]]> TRUNC(LAST_DAY(dt), 'iw') + 6
                                    - TRUNC(TRUNC(dt, 'mm'), 'iw')
                                    + 1
            )
        GROUP BY TRUNC(dt, 'iw')
        ORDER BY set_weekstart

    </select>

    <select id="DateOneWeekXML" resultType="com.fivekm_home.charge.domain.DATE.DateOneWeekDAO">
        select to_char(#{DATE_SEND} - to_number(to_char(#{DATE_SEND}, 'd')),'yyyy-mm-dd') as ONE_WEEK
        from dual
    </select>

</mapper>
